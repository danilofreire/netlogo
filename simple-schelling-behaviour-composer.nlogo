;; This file was generated by the Behaviour Composer at modelling4all.org on Sun Jun 21 11:22:25 UTC 2015
;; The model can be found at https://m4a-gae.appspot.com/m/?frozen=1j25aKKEs_apjz_HBQBU48

breed [objects object]

patches-own [pzcor ]

turtles-own [
 scheduled-behaviours behaviours-at-tick-start current-behaviours current-behaviour behaviour-removals rules 
 kind dead dirty
 my-z zcor pitch roll 
]

breed [pens pen]

; The following are needed by the Behaviour Composer
globals [
 time cycle-finish-time behind-schedule times-scheduled frame-duration delta-t stop-running
 world-geometry mean-x mean-y mean-z plotting-commands histogram-plotting-commands 
 behaviour-procedure-numbers behaviour-names internal-the-other 
 button-command radian need-to-clear-drawing
 observer-commands 
 objects-with-something-to-do
 maximum-plot-generations plot-generation
 prototypes total-time
 update-patch-attributes-needed
 state-restored-after-setup
 temp
]

to the-model [ globals-not-to-be-initialised ] 
   initialise-globals globals-not-to-be-initialised 
   create-objects 300 
                  [ set kind 
                        "Household" 
                    initialise-object ] 
   ask all-of-kind "Household" 
       [ -COLOR-2711 
         -SHAPE-1365 
         -SIZE-521 
         -JUMP-TO-UNOCCUPIED-LOCATION-IN-REGION-533 
         -MOVE-IF-UNHAPPY-103 ] 
end

to -COLOR-2711
               ; Change the color of this agent.  
   set color 
       one-of [ red green ] 
end

to -SHAPE-1365
               ; Change the appearance to one of the defined shapes.  
   set shape 
       "house" 
end

to -SIZE-521
             ; Change size of this agent.  
   set size 
       1 
end

to -JUMP-TO-UNOCCUPIED-LOCATION-IN-REGION-533
                                              ; Jump to a random unoccupied location in the specified region.  
   let unoccupied-location 
       random-unoccupied-location ( min-pxcor ) ( max-pxcor ) ( min-pycor ) ( max-pycor ) 
   set xcor 
       first unoccupied-location 
   set ycor 
       second unoccupied-location 
end

to -MOVE-IF-UNHAPPY-103
                        ; Move to a patch that has nothing there.  
   do-after ( 1 ) 
            task [ do-every ( 1 ) 
                            task [ let this-color 
                                       ( color ) 
                                   let different 
                                       ( count ( turtles-on neighbors ) with [ color != this-color ] ) 
                                   let total 
                                       ( count ( turtles-on neighbors ) ) 
                                   if ( different > total * my-threshold ) 
                                      [ let unoccupied-patch 
                                            ( one-of patches with [ not any? objects-here with [ not hidden? ] ] ) 
                                        if ( is-patch? unoccupied-patch ) 
                                           [ move-to unoccupied-patch ] ] ] ] 
end

to-report random-unoccupied-location [min-xcor max-xcor min-ycor max-ycor]
  let unoccupied-patch one-of patches with 
                                      [min-xcor <= pxcor and
                                       max-xcor >= pxcor and
                                       min-ycor <= pycor and
                                       max-ycor >= pycor and
                                       not any? objects-here with [not hidden?]]
 if-else is-patch? unoccupied-patch
   [report [(list pxcor pycor)] of unoccupied-patch]
   [report (list xcor ycor)]
end

to-report update-attributes
  report false
end

to initialise-patch-attributes
end

to initialise-globals [globals-not-to-be-initialised]
 set update-patch-attributes-needed false
end

to update-patch-attributes
end

to-report update-turtle-state
 report false
end

to initialise-previous-state
end

to update-all-turtle-states
end

to initialise-attributes
end

; The following are NetLogo library procedures and reporters used by the BehaviourComposer
; New BSD license
; See http://modelling4all.org
; Authored by Ken Kahn; Last updated 13 Feb 2015

to start [globals-not-to-be-initialised]
 initialise
 the-model globals-not-to-be-initialised
 finish-setup  
 create-pens 1 ; for drawing lines
 ask pens [hide-turtle]                    
end

to setup
  setup-except []
end

to setup-except [globals-not-to-be-initialised]
 start globals-not-to-be-initialised
 set total-time 0
 if go-until (delta-t - .000001) []  ; ignore result
 ask objects [initialise-previous-state]
end

to initialise
 let saved-state-restored-after-setup state-restored-after-setup
 if-else maximum-plot-generations > 0
    [if-else plot-generation <= maximum-plot-generations 
        [set plot-generation plot-generation + 1
          ; clear all but plots and output
         clear-patches
         clear-drawing
         clear-turtles]
        [clear-all
         set plot-generation 0]]
    [clear-all]
 reset-ticks
 reset-timer
 set time -1
 set times-scheduled []
 set behind-schedule 0
 set plotting-commands []
 set histogram-plotting-commands []
 set button-command ""
 set radian 57.29577951308232
 set need-to-clear-drawing false
 set observer-commands []
 set stop-running false
 if delta-t = 0 [set delta-t 1] ; give default value if none given
 if frame-duration = 0 [set frame-duration delta-t]
 if world-geometry = 0 [set world-geometry 1]
 ask-every-patch task [initialise-patch-attributes]
 set state-restored-after-setup saved-state-restored-after-setup
end

to initialise-object
 set scheduled-behaviours []
 set current-behaviours []
 set behaviour-removals []
 set rules []
 set dead false
 initialise-attributes
end

to finish-setup
 ; faster than ask objects since doesn't shuffle
 set objects-with-something-to-do objects
 let ignore1 objects with [update-attributes]
 ask objects with [rules != []] [run-rules]
 update-all-turtle-states
 set time 0
end

to go
 reset-timer ; reset timer so pause and resume don't have leftover time
 if go-until -1 
    [set stop-running false ; so it can be started up again 
     stop]
    set total-time total-time + timer
end

to setup-only-if-needed
  if times-scheduled = 0 [setup]
end

to-report go-until [stop-time]
 ; this is run by the 'go' button and runs the scheduled events and updates the turtle states and plots
 setup-only-if-needed
 if observer-commands != []
    [run-observer-commands]
 if-else times-scheduled = []
   ; following uses a hack to avoid the overhead of ask shuffling the agent set
   [set objects-with-something-to-do objects with [rules != []]
    ask objects-with-something-to-do [run-rules] ; nothing scheduled but rules may be triggered by time
    ; rules may have added behaviours or set 'dead' so can't re-use objects-with-something-to-do
    ask objects [finish-tick]
    if observer-commands != []
       [run-observer-commands]
    set time time + frame-duration]
   [if-else time <= 0
      [set cycle-finish-time first times-scheduled]
      [set cycle-finish-time cycle-finish-time + frame-duration]
     if stop-time > 0 [set cycle-finish-time stop-time]
     while [times-scheduled != [] and first times-scheduled <= cycle-finish-time]
       [; nothing happening so skip ahead to next event
        set time first times-scheduled
        set times-scheduled but-first times-scheduled
        set objects-with-something-to-do objects with [scheduled-behaviours != [] or rules != []]
        ask objects-with-something-to-do [start-tick]
        ; above may have added behaviours or set 'dead' so can't re-use objects-with-something-to-do 
        ask objects [finish-tick]
        if observer-commands != []
           [run-observer-commands]
        if need-to-clear-drawing
           [clear-drawing
            set need-to-clear-drawing false]]]
 if observer-commands != []
    [run-observer-commands]
 update-all-turtle-states
 if update-patch-attributes-needed [ask-every-patch task [update-patch-attributes]]
 tick-advance time - ticks
 run-plotting-commands
 report not any? objects = 0 or stop-running or (stop-time > 0 and time >= stop-time)
end

to run-observer-commands
  let commands observer-commands
  set observer-commands []
  ; run each command without ANY commands pending
  forEach commands [run ?]
end

to run-plotting-commands
 forEach plotting-commands [if is-agent? first ? [ask first ? [update-plot item 1 ? runresult item 2 ? runresult item 3 ?]]] 
 forEach histogram-plotting-commands [if is-agent? first ? [ask first ? [update-histogram item 1 ? item 2 ? item 3 ?]]]       
end

to update-plot [name-of-plot x y]
 if time >= 0
  [set-current-plot name-of-plot
   plotxy x y]
end

to update-histogram [name-of-plot population-reporter value-reporter]
 if time >= 0
  [set-current-plot name-of-plot
   histogram [runresult value-reporter] of runresult population-reporter]
end

;; behaviours are represented by a list:
;; scheduled-time behaviour-name
;; behaviours are kept in ascending order of the scheduled-time

to remove-behaviour-now [name]
 set scheduled-behaviours remove-behaviour-from-list name scheduled-behaviours
end

to do-every [interval actions]        
 ; does it now and schedules the next occurrence interval ticks in the future
 ; schedules first in case action updates the current-behaviour variable
 if-else not is-number? interval or interval <= 0
   [user-message (word "Can only repeat something a positive number of times. Not " interval " " actions)]
   [if-else time < 0 
      [insert-behaviour 0 (list (list actions interval))]
      [do-every-internal interval actions]]
end

to do-every-internal [interval actions]
 insert-behaviour time + interval (list (list actions interval))
 run-procedure actions
end

to do-every-dynamic [interval-reporter actions]
 insert-behaviour time + run-result interval-reporter (list (list actions interval-reporter))
 run-procedure actions
end

to do-after [duration actions]
 ; schedules this duration ticks in the future 
 if-else is-list? current-behaviour
    ; from the time this event was scheduled to run; not necessarily the current time
    [do-at-time first current-behaviour + duration actions]
    [if-else time > 0 
       [do-at-time time + duration actions]
       [do-at-time duration actions]]
end

to do-at-time [scheduled-time actions]
 if-else scheduled-time <= time
   [run actions]
   [insert-behaviour scheduled-time (list actions)]
end

to start-tick
 set behaviours-at-tick-start scheduled-behaviours
 set current-behaviours scheduled-behaviours
 set scheduled-behaviours []
 while [current-behaviours != []]
       [let simulation-time first first current-behaviours
        if-else simulation-time > time 
          [set scheduled-behaviours merge-behaviours scheduled-behaviours current-behaviours
           set current-behaviours []] ; stop this round
          [set current-behaviour first current-behaviours
           forEach but-first current-behaviour run-procedure 
           set current-behaviour 0
           ; procedure may have reset current-behaviours to []
           if current-behaviours != [] 
              [set current-behaviours but-first current-behaviours]]]
 if rules != [] [run-rules]
 if behaviour-removals != []
    [forEach behaviour-removals
        [ask first ? [remove-behaviour-now item 1 ?]]
     set behaviour-removals []]
end

to finish-tick
 ; this should happen after all objects have run start-tick
 let ignore update-attributes
 if dead [die]
end

to-report all-of-kind [kind-name]
 report objects with [kind = kind-name]
end

to run-rules
 let current-rules rules
 set rules []
 ; so can remove a rule below while still going down the list
 ;; could add error handling below
 forEach current-rules
    [if-else runresult first ?
       [run first but-first ?
        if item 2 ?
           ; is a 'whenever' rule so put it back on the list of rules
           [set rules fput ? rules]]
       [set rules fput ? rules]]
end

to insert-behaviour [scheduled-time rest-of-behaviour]
 ; inserts in schedule keeping it sorted by scheduled time
 set times-scheduled insert-ordered scheduled-time times-scheduled
 set scheduled-behaviours insert-behaviour-in-list scheduled-time rest-of-behaviour scheduled-behaviours
end

to-report insert-ordered [new-time times]
  if-else member? new-time times
    [report times]
    [report sort fput new-time times]
end

to-report insert-behaviour-in-list [scheduled-time rest-of-behaviour behaviours]
 ; recursive version took 10% longer
 let earlier-behaviours []
 while [behaviours != []] 
    [let current-time first first behaviours
      if current-time = scheduled-time
        [let new-behaviour lput first rest-of-behaviour first behaviours
          report sentence earlier-behaviours fput new-behaviour but-first behaviours]
      if current-time > scheduled-time 
        [report sentence earlier-behaviours fput fput scheduled-time rest-of-behaviour behaviours]
     set earlier-behaviours lput first behaviours earlier-behaviours
     set behaviours but-first behaviours]
 report sentence earlier-behaviours (list fput scheduled-time rest-of-behaviour)
end

to-report remove-behaviour-from-list [procedure-name behaviours]
 report map [remove-behaviour-from-behaviours-at-time-t procedure-name ?] behaviours
end

to-report remove-behaviour-from-behaviours-at-time-t [procedure-name behaviours-at-time-t]
 forEach but-first behaviours-at-time-t ; first is the time -- skip that
   [if equivalent-micro-behaviour? (ifelse-value is-list? ? [first ?] [?]) procedure-name
      [report remove ? behaviours-at-time-t]]
 report behaviours-at-time-t
end

to-report equivalent-micro-behaviour? [task-1 task-2]
 if (task-1 = task-2) [report true]
 ; different copies of the same micro-behaviour are equivalent for removals
 let serial-number-length 6
 let task-description-1 (word task-1)
 ; need to obtain the procedure name of the task by extracting it from print format
 ; ignore first 30 characters, serial number, and final parenthesis
 if (length task-description-1 - (serial-number-length + 1) <= 30) [report false]
 let name-1 substring task-description-1 30 (length task-description-1 - (serial-number-length + 1))
 let name-2 0
 if-else (is-string? task-2)
   ; older way was to use strings rather than tasks
   [set name-2 substring task-2 0 (length task-2 - serial-number-length)]
   [let task-description-2 (word task-2)
    if (length task-description-2 - (serial-number-length + 1) <= 30) [report false]
    set name-2 substring task-description-2 30 (length task-description-2 - (serial-number-length + 1))]
 report name-1 = name-2
end

to remove-behaviours [behaviours]
 forEach behaviours [remove-behaviour ?]
end

to remove-behaviour [name]
  set behaviour-removals fput (list self name) behaviour-removals
end

to-report merge-behaviours [behaviours1 behaviours2]
 ; both lists are already sorted
 if behaviours1 = [] [report behaviours2]
 if behaviours2 = [] [report behaviours1]
 if-else first first behaviours1 < first first behaviours2 
   [report fput first behaviours1 merge-behaviours but-first behaviours1 behaviours2]
   [report fput first behaviours2 merge-behaviours behaviours1 but-first behaviours2]
end

to-report second [l]
 report first but-first l
end

to ask-every-patch [procedure-name]
 ; a hack but faster since doesn't randomise the patches as ask does
 let ignore patches with [run-false procedure-name]
end

to-report run-false [procedure-name]
 run procedure-name
 report false
end

to-report list-to-agentset [agent-list]
 ; deprecated but kept for backwards compatibility 
 report turtle-set agent-list
end

to run-procedure [name]
 if-else is-list? name 
    [let target-or-frequency item 1 name
     if-else is-number? target-or-frequency
        [do-every-internal target-or-frequency first name]
        [if-else is-agent? target-or-frequency
            [ask target-or-frequency [run first name]]
            [do-every-dynamic target-or-frequency first name] ]]
    [run name]
end

@#$#@#$#@
GRAPHICS-WINDOW
104
10
618
545
10
10
24.0
1
10
1
1
1
0
1
1
1
-10
10
-10
10
1
1
1
time
30.0

BUTTON
5
5
66
40
SETUP
setup
NIL
1
T
OBSERVER
NIL
S
NIL
NIL
1

BUTTON
5
45
66
80
GO
go
T
1
T
OBSERVER
NIL
G
NIL
NIL
1

BUTTON
5
85
68
118
PAUSE
set stop-running true
NIL
1
T
OBSERVER
NIL
.
NIL
NIL
1

SLIDER
625
10
875
43
my-threshold
my-threshold
0
1
0.5
.01
1
NIL
HORIZONTAL

@#$#@#$#@
## WHAT IS IT?

(a general understanding of what the model is trying to show or explain)

## HOW IT WORKS

(what rules the agents use to create the overall behavior of the model)

## HOW TO USE IT

(how to use the model, including a description of each of the items in the Interface tab)

## THINGS TO NOTICE

(suggested things for the user to notice while running the model)

## THINGS TO TRY

(suggested things for the user to try to do (move sliders, switches, etc.) with the model)

## EXTENDING THE MODEL

(suggested things to add or change in the Code tab to make the model more complicated, detailed, accurate, etc.)

## NETLOGO FEATURES

(interesting or unusual features of NetLogo that the model uses, particularly in the Code tab; or where workarounds were needed for missing features)

## RELATED MODELS

(models in the NetLogo Models Library and elsewhere which are of related interest)

## CREDITS AND REFERENCES

(a reference to the model's URL on the web if it has one, as well as any other necessary credits, citations, and links)
@#$#@#$#@
default
true
0
Polygon -7500403 true true 150 5 40 250 150 205 260 250

house
false
0
Rectangle -7500403 true true 45 120 255 285
Rectangle -16777216 true false 120 210 180 285
Polygon -7500403 true true 15 120 150 15 285 120
Line -16777216 false 30 120 270 120

@#$#@#$#@
NetLogo 5.2.0
@#$#@#$#@
default
0.0
-0.2 0 0.0 1.0
0.0 1 1.0 0.0
0.2 0 0.0 1.0
link direction
true
0
Line -7500403 true 150 150 90 180
Line -7500403 true 150 150 210 180
@#$#@#$#@
@#$#@#$#@
@#$#@#$#@
@#$#@#$#@
default
0.0
-0.2 0 0.0 1.0
0.0 1 1.0 0.0
0.2 0 0.0 1.0
link direction
true
0
Line -7500403 true 150 150 90 180
Line -7500403 true 150 150 210 180

@#$#@#$#@
0
@#$#@#$#@
